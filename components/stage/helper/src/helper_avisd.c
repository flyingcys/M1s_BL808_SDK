#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#include <FreeRTOS.h>
#include <task.h>
#include <queue.h>
#include <timers.h>
#include <aos/kernel.h>
#include <aos/yloop.h>
#include <sccb.h>
#include <cli.h>
#include <vfs.h>
#include <sys/fcntl.h>

#include "utils_log.h"

#include <bl_cam.h>
#include <bl_gpio.h>
#include <bl_cpu.h>
#include <camera.h>
#include <mjpeg_booster.h>
#include <mjpeg_sw_buffer.h>
#include <bl60x_mjpeg.h>
#include <bl60x_common.h>

#define AVISD_ASSERT(EXPR)                                                    \
if (!(EXPR)) {                                                                \
    while (1) {                                                               \
        log_error("(%s) has assert failed at %s.\n", #EXPR, __FUNCTION__);    \
        aos_msleep(100);                                                      \
    }                                                                         \
}

#define U16HTONL(x) ((((x) & (uint16_t)0x00ffUL) << 8) | \
                     (((x) & (uint16_t)0xff00UL) >> 8)) 
#define U16NTOHL(x) U32HTONL(x)

#define AVI_FILE_NAME_DEF               "/sdcard/blavi.avi"

#define DEBUG_MJPEG_SAVED               0
#if DEBUG_MJPEG_SAVED
#define TEST_MJPEG_NAME                 "/sdcard/%ld.jpeg"
#endif
#define MJPEG_TEST_TOTAL_FRAME          (750)

#define MJPEG_HEADER_SIZE               (612)
#define MJPEG_HEIGHT_OFFSET             (140 + 5 + 7)
#define MJPEG_WIDTH_OFFSET              (140 + 5 + 2 + 7)
#define MJPEG_PAYLOAD_MAX_SIZE          (300 * 1024)
#define MJPEG_TAIL_SIZE                 (2)

/* avi file define */
#define RIFF_FILE_HEAD_ARG              (150)       /* (240 - 8) */
#define AVI_SD_ALIGN_BLOCK_SIZE         (512)       /* 512 Bytes */
#define AVI_HEADER_SIZE                 (sizeof(avi_head_t))
#define AVI_BUF_MAXSIZE                 (MJPEG_HEADER_SIZE + MJPEG_PAYLOAD_MAX_SIZE + MJPEG_TAIL_SIZE + AVI_SD_ALIGN_BLOCK_SIZE + AVI_HEADER_SIZE)

/* ------------------------------------- avi typedef start ------------------------------------- */
typedef uint32_t DWORD;
typedef int32_t LONG;
typedef uint16_t WORD;
typedef uint8_t BYTE;

typedef struct {
    DWORD dwRIFF;
    DWORD dwSize;
    DWORD dwFourCC;
} MainAVIRiff;

typedef struct {
    DWORD dwList;
    DWORD dwSize;
    DWORD dwFourCC;
} MainAVIList;

typedef struct {
    DWORD dwFourCC;
    DWORD dwSize;

    DWORD dwMicroSecPerFrame ;
    DWORD dwMaxBytesPerSec;
    DWORD dwPaddingGranularity;
    DWORD dwFlags;
    DWORD dwTotalFrame;
    DWORD dwInitialFrames;
    DWORD dwStreams;
    DWORD dwSuggestedBufferSize;

    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwReserved[4];
} MainAVIHeader;

typedef struct {
    DWORD dwFourCC;
    DWORD dwSize;
    DWORD fccType;
    DWORD fccHandler;
    DWORD dwFlags;
    WORD  wPriority;
    WORD  wLanguage;
    DWORD dwInitialFrames;
    DWORD dwScale;
    DWORD dwRate;
    DWORD dwStart;
    DWORD dwLength;
    DWORD dwSuggestedBufferSize;
    DWORD dwQuality;
    DWORD dwSampleSize;
} AVIStreamHeader;

typedef struct tagEXBMINFOHEADER {
    DWORD dwFourCC;
    DWORD dwSize;
    DWORD biSize;
    LONG  biWidth;
    LONG  biHeight;
    WORD  biPlanes;
    WORD  biBitCount;
    DWORD biCompression;
    DWORD biSizeImage;
    LONG  biXPelsPerMeter;
    LONG  biYPelsPerMeter;
    DWORD biClrUsed;
    DWORD biClrImportant;
} EXBMINFOHEADER;

typedef struct {
    DWORD dwList;
    DWORD dwSize;
    DWORD dwFourCC1;
    DWORD dwFourCC2;
    DWORD szs;
    DWORD totalframes;
} AVIDmHeader;

typedef struct __avi_head {
    MainAVIRiff avi_riff;
    MainAVIList avi_list_hdrl;
    MainAVIHeader avi_avih;
    MainAVIList avi_list_strl;
    AVIStreamHeader avi_strh;
    EXBMINFOHEADER avi_strf;
    AVIDmHeader avi_dm;
    MainAVIList avi_list_movi;
} avi_head_t;

typedef struct __avi_body {
    DWORD dwList;
    DWORD dwSize;
} avi_body_t;

typedef struct {
    DWORD dwList;
    DWORD dwSize;
} AVITailH_t;

typedef struct {
    DWORD dwList;
    DWORD dwSize;
    DWORD offset;
    DWORD mjpeglen;
} AVITailData_t;

typedef struct __avi_tail {
    AVITailH_t tailh;
    AVITailData_t taildata;
} avi_tail_t;
/* ------------------------------------- avi typedef end ------------------------------------- */

const uint8_t code_mjpeg_tail_buf[2] = {0xFF, 0xD9};
const uint8_t code_mjpeg_header_Q5[] = {
    0xFF, 0xD8,
    0xFF, 0xFE, 0x00, 0x03, 0x55, 0x55, 0x55,
    0xFF, 0xDB, 0x00, 0x43, 0x00, 0xA0, 0x6E, 0x78, 0x8C, 0x78,
    0x64, 0xA0, 0x8C, 0x82, 0x8C, 0xB4, 0xAA, 0xA0, 0xBE, 0xF0,
    0xFF, 0xFF, 0xF0, 0xDC, 0xDC, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xDB, 0x00, 0x43, 0x01, 0xAA, 0xB4, 0xB4, 0xF0, 0xD2,
    0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xC0, 0x00, 0x11, 0x08, 0x01, 0x68, 0x02, 0x80, 0x03,
    0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
    0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03,
    0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01,
    0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14,
    0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15,
    0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4,
    0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
    0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xC4, 0x00, 0x1F, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04,
    0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02,
    0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
    0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32,
    0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23,
    0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
    0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2,
    0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
    0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4,
    0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5,
    0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
    0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
    0x11, 0x00, 0x3F, 0x00};

const uint8_t code_mjpeg_header_Q10[] = {
    0xFF, 0xD8,
    0xFF, 0xFE, 0x00, 0x03, 0x55, 0x55, 0x55,
    0xFF, 0xDB, 0x00, 0x43, 0x00, 0x50, 0x37, 0x3C, 0x46, 0x3C,
    0x32, 0x50, 0x46, 0x41, 0x46, 0x5A, 0x55, 0x50, 0x5F, 0x78,
    0xC8, 0x82, 0x78, 0x6E, 0x6E, 0x78, 0xF5, 0xAF, 0xB9, 0x91,
    0xC8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xDB, 0x00, 0x43, 0x01, 0x55, 0x5A, 0x5A, 0x78, 0x69,
    0x78, 0xEB, 0x82, 0x82, 0xEB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xC0, 0x00, 0x11, 0x08, 0x01, 0x68, 0x02, 0x80, 0x03,
    0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
    0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03,
    0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01,
    0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14,
    0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15,
    0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4,
    0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
    0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xC4, 0x00, 0x1F, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04,
    0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02,
    0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
    0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32,
    0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23,
    0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
    0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2,
    0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
    0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4,
    0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5,
    0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
    0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
    0x11, 0x00, 0x3F, 0x00};

const uint8_t code_mjpeg_header_Q25[] = {
    0xFF, 0xD8,
    0xFF, 0xFE, 0x00, 0x03, 0x55, 0x55, 0x55,
    0xFF, 0xDB, 0x00, 0x43, 0x00, 0x20, 0x16, 0x18, 0x1C, 0x18,
    0x14, 0x20, 0x1C, 0x1A, 0x1C, 0x24, 0x22, 0x20, 0x26, 0x30,
    0x50, 0x34, 0x30, 0x2C, 0x2C, 0x30, 0x62, 0x46, 0x4A, 0x3A,
    0x50, 0x74, 0x66, 0x7A, 0x78, 0x72, 0x66, 0x70, 0x6E, 0x80,
    0x90, 0xB8, 0x9C, 0x80, 0x88, 0xAE, 0x8A, 0x6E, 0x70, 0xA0,
    0xDA, 0xA2, 0xAE, 0xBE, 0xC4, 0xCE, 0xD0, 0xCE, 0x7C, 0x9A,
    0xE2, 0xF2, 0xE0, 0xC8, 0xF0, 0xB8, 0xCA, 0xCE, 0xC6,
    0xFF, 0xDB, 0x00, 0x43, 0x01, 0x22, 0x24, 0x24, 0x30, 0x2A,
    0x30, 0x5E, 0x34, 0x34, 0x5E, 0xC6, 0x84, 0x70, 0x84, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xFF, 0xC0, 0x00, 0x11, 0x08, 0x01, 0x68, 0x02, 0x80, 0x03,
    0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
    0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03,
    0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01,
    0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14,
    0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15,
    0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4,
    0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
    0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xC4, 0x00, 0x1F, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04,
    0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02,
    0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
    0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32,
    0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23,
    0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
    0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2,
    0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
    0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4,
    0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5,
    0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
    0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
    0x11, 0x00, 0x3F, 0x00};

const uint8_t code_mjpeg_header_Q50[] = {
    0xFF, 0xD8,
    0xFF, 0xFE, 0x00, 0x03, 0x55, 0x55, 0x55,
    0xFF, 0xDB, 0x00, 0x43, 0x00, 0x10, 0x0B, 0x0C, 0x0E, 0x0C,
    0x0A, 0x10, 0x0E, 0x0D, 0x0E, 0x12, 0x11, 0x10, 0x13, 0x18,
    0x28, 0x1A, 0x18, 0x16, 0x16, 0x18, 0x31, 0x23, 0x25, 0x1D,
    0x28, 0x3A, 0x33, 0x3D, 0x3C, 0x39, 0x33, 0x38, 0x37, 0x40,
    0x48, 0x5C, 0x4E, 0x40, 0x44, 0x57, 0x45, 0x37, 0x38, 0x50,
    0x6D, 0x51, 0x57, 0x5F, 0x62, 0x67, 0x68, 0x67, 0x3E, 0x4D,
    0x71, 0x79, 0x70, 0x64, 0x78, 0x5C, 0x65, 0x67, 0x63,
    0xFF, 0xDB, 0x00, 0x43, 0x01, 0x11, 0x12, 0x12, 0x18, 0x15,
    0x18, 0x2F, 0x1A, 0x1A, 0x2F, 0x63, 0x42, 0x38, 0x42, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0xFF, 0xC0, 0x00, 0x11, 0x08, 0x01, 0x68, 0x02, 0x80, 0x03,
    0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
    0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03,
    0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01,
    0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14,
    0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15,
    0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4,
    0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
    0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xC4, 0x00, 0x1F, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04,
    0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02,
    0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
    0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32,
    0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23,
    0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
    0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2,
    0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
    0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4,
    0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5,
    0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
    0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
    0x11, 0x00, 0x3F, 0x00};

const uint8_t code_mjpeg_header_Q75[] = {
    0xFF, 0xD8,
    0xFF, 0xFE, 0x00, 0x03, 0x55, 0x55, 0x55,
    0xFF, 0xDB, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06,
    0x05, 0x08, 0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0A, 0x0C,
    0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12, 0x13, 0x0F,
    0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
    0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28,
    0x37, 0x29, 0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27,
    0x39, 0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34, 0x32,
    0xFF, 0xDB, 0x00, 0x43, 0x01, 0x09, 0x09, 0x09, 0x0C, 0x0B,
    0x0C, 0x18, 0x0D, 0x0D, 0x18, 0x32, 0x21, 0x1C, 0x21, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0xFF, 0xC0, 0x00, 0x11, 0x08, 0x01, 0x68, 0x02, 0x80, 0x03,
    0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
    0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03,
    0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01,
    0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14,
    0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15,
    0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4,
    0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
    0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xC4, 0x00, 0x1F, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04,
    0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02,
    0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
    0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32,
    0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23,
    0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
    0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2,
    0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
    0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4,
    0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5,
    0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
    0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
    0x11, 0x00, 0x3F, 0x00};

const uint8_t code_mjpeg_header_Q100[] = {
    0xFF, 0xD8,
    0xFF, 0xFE, 0x00, 0x03, 0x55, 0x55, 0x55,
    0xFF, 0xDB, 0x00, 0x43, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0xFF, 0xDB, 0x00, 0x43, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0xFF, 0xC0, 0x00, 0x11, 0x08, 0x01, 0x68, 0x02, 0x80, 0x03,
    0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
    0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03,
    0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01,
    0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14,
    0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15,
    0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4,
    0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
    0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
    0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xC4, 0x00, 0x1F, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0A, 0x0B,
    0xFF, 0xC4, 0x00, 0xB5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04,
    0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02,
    0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
    0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32,
    0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23,
    0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
    0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2,
    0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
    0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4,
    0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5,
    0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
    0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA,
    0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
    0x11, 0x00, 0x3F, 0x00};

static uint8_t MJPEG_quality_current  = 50;  /* 5, 10, 25, 50, 75, 100 */

/* avi static */
uint32_t jpgs_totallen = 0;
uint32_t jpgs_sum = 0;
uint32_t jpgs_width = 640;
uint32_t jpgs_high = 360;
uint32_t jpgs_fps = 1;
uint32_t jpgs_usleep = 1000000;

uint32_t savesd_start_time = 0;
uint32_t savesd_end_time = 0;

static uint8_t *avi_buf = NULL;
static uint32_t *avi_mjpeg_size = NULL;
static uint8_t *avi_header_p = NULL;
static uint32_t avibuf_head_index = 0;
static uint32_t avibuf_tail_index = 0;
static int file_sample_fd = -1;

uint32_t avi_copy_tmp1 = 0;
uint32_t avi_copy_tmp2 = 0;
uint32_t avi_copy_total = 0;

uint32_t avi_wsd_tmp1 = 0;
uint32_t avi_wsd_tmp2 = 0;
uint32_t avi_wsd_total = 0;

#define AVI_FILE_NAME_MAXLEN (64)
static char avi_file_name[AVI_FILE_NAME_MAXLEN] = AVI_FILE_NAME_DEF;

/* avi func */
void avi_head_update(avi_head_t *head, uint32_t j_totallen, uint32_t j_sum,
uint32_t j_width, uint32_t j_high, uint32_t j_fps, uint32_t j_usleep)
{
    /* MainAVIRiff avi_riff; */
    head->avi_riff.dwSize = RIFF_FILE_HEAD_ARG + 12 + j_totallen + 8*j_sum + 8 + 16*j_sum;

    /* MainAVIList avi_list_hdrl; */

    /* MainAVIHeader avi_avih; */
    head->avi_avih.dwMicroSecPerFrame = j_usleep;
    head->avi_avih.dwTotalFrame = j_sum;
    head->avi_avih.dwWidth = j_width;
    head->avi_avih.dwHeight = j_high;

    /* MainAVIList avi_list_strl */

    /* AVIStreamHeader avi_strh */
    head->avi_strh.dwRate = j_fps;
    head->avi_strh.dwLength = j_sum;

    /* EXBMINFOHEADER avi_strf */
    head->avi_strf.biWidth = j_width;
    head->avi_strf.biHeight = j_high;
    head->avi_strf.biSizeImage = ((j_width*24/8 + 3)&0xFFFFFFFC)*j_high;

    /* AVIDmHeader avi_dm */
    head->avi_dm.totalframes = j_sum;

    /* MainAVIList avi_list_movi */
    head->avi_list_movi.dwSize = j_totallen + 4 + 8*j_sum;
}

static void avi_head_init(avi_head_t *head)
{
    uint32_t j_totallen = 153480;
    uint32_t j_sum = MJPEG_TEST_TOTAL_FRAME;
    uint32_t j_width = 640;
    uint32_t j_high = 360;
    uint32_t j_fps = 10;
    uint32_t j_usleep = 100000;

    /* MainAVIRiff avi_riff; */
    memcpy(&head->avi_riff.dwRIFF, "RIFF", 4);
    head->avi_riff.dwSize = RIFF_FILE_HEAD_ARG + 12 + j_totallen + 8*j_sum + 8 + 16*j_sum;
    memcpy(&head->avi_riff.dwFourCC, "AVI ", 4);

    /* MainAVIList avi_list_hdrl; */
    memcpy(&head->avi_list_hdrl.dwList, "LIST", 4);
    head->avi_list_hdrl.dwSize = 0xD0;
    memcpy(&head->avi_list_hdrl.dwFourCC, "hdrl", 4);

    /* MainAVIHeader avi_avih; */
    memcpy(&head->avi_avih.dwFourCC, "avih", 4);
    head->avi_avih.dwSize = 0x38;
    head->avi_avih.dwMicroSecPerFrame = j_usleep;
    head->avi_avih.dwMaxBytesPerSec = 7000;
    head->avi_avih.dwPaddingGranularity = 0;
    head->avi_avih.dwFlags = 16;
    head->avi_avih.dwTotalFrame = j_sum;
    head->avi_avih.dwInitialFrames = 0;
    head->avi_avih.dwStreams = 1;
    head->avi_avih.dwSuggestedBufferSize = 0;
    head->avi_avih.dwWidth = j_width;
    head->avi_avih.dwHeight = j_high;
    memset(head->avi_avih.dwReserved, 0, 4*sizeof(DWORD));

    /* MainAVIList avi_list_strl */
    memcpy(&head->avi_list_strl.dwList, "LIST", 4);
    head->avi_list_strl.dwSize = 0x84;
    memcpy(&head->avi_list_strl.dwFourCC, "strl", 4);

    /* AVIStreamHeader avi_strh */
    memcpy(&head->avi_strh.dwFourCC, "strh", 4);
    head->avi_strh.dwSize = 0x30;
    memcpy(&head->avi_strh.fccType, "vids", 4);
    memcpy(&head->avi_strh.fccHandler, "MJPG", 4);
    head->avi_strh.dwFlags = 0;
    head->avi_strh.wPriority = 0;
    head->avi_strh.wLanguage = 0;
    head->avi_strh.dwInitialFrames = 0;
    head->avi_strh.dwScale = 1;
    head->avi_strh.dwRate = j_fps;
    head->avi_strh.dwStart = 0;
    head->avi_strh.dwLength = j_sum;
    head->avi_strh.dwSuggestedBufferSize = 0;
    head->avi_strh.dwQuality = 0;
    head->avi_strh.dwSampleSize = 0;

    /* EXBMINFOHEADER avi_strf */
    memcpy(&head->avi_strf.dwFourCC, "strf", 4);
    head->avi_strf.dwSize = 40;
    head->avi_strf.biSize = 40;
    head->avi_strf.biWidth = j_width;
    head->avi_strf.biHeight = j_high;
    head->avi_strf.biPlanes = 1;
    head->avi_strf.biBitCount = 24;
    memcpy(&head->avi_strf.biCompression, "MJPG", 4);
    head->avi_strf.biSizeImage = ((j_width*24/8 + 3)&0xFFFFFFFC)*j_high;
    head->avi_strf.biXPelsPerMeter = 0;
    head->avi_strf.biYPelsPerMeter = 0;
    head->avi_strf.biClrUsed = 0;
    head->avi_strf.biClrImportant = 0;

    /* AVIDmHeader avi_dm */
    memcpy(&head->avi_dm.dwList, "LIST", 4);
    head->avi_dm.dwSize = 16;
    memcpy(&head->avi_dm.dwFourCC1, "odml", 4);
    memcpy(&head->avi_dm.dwFourCC2, "dmlh", 4);
    head->avi_dm.szs = 4;
    head->avi_dm.totalframes = j_sum;

    /* MainAVIList avi_list_movi */
    memcpy(&head->avi_list_movi.dwList, "LIST", 4);
    head->avi_list_movi.dwSize = j_totallen + 4 + 8*j_sum;
    memcpy(&head->avi_list_movi.dwFourCC, "movi", 4);
}

/* avi buf ops start */
static uint8_t *avi_buf_p(void)
{
    return (avi_buf + avibuf_head_index);
}

static uint32_t avi_buf_size(void)
{
    return (avibuf_tail_index - avibuf_head_index);
}

static void avi_buf_copy(void *buf, uint32_t buf_size)
{
    if ( (avibuf_tail_index + buf_size) >= AVI_BUF_MAXSIZE) {
        log_error("please set AVI_BUF_MAXSIZE bigger.\r\n");
        return;
    }

    avi_copy_tmp1 = (uint32_t)(*((uint32_t *)0x60b00120));
    memcpy((avi_buf + avibuf_tail_index), buf, buf_size);
    avi_copy_tmp2 = (uint32_t)(*((uint32_t *)0x60b00120));
    if (savesd_start_time > 0) {
        avi_copy_total += (avi_copy_tmp2 - avi_copy_tmp1);
    }

    avibuf_tail_index += buf_size;
}
/* avi buf ops end */

static void mjpegsd_init(void)
{
    avi_head_t *avi_header_buf = NULL;

    /* open bl_sample.avi */
    file_sample_fd = aos_open((const char *)avi_file_name, O_RDWR | O_CREAT | O_TRUNC);
    if (0 > file_sample_fd) {
        log_error("open error.\r\n");
        return;
    }

    /* malloc  */
    avi_mjpeg_size = pvPortMallocDMA(MJPEG_TEST_TOTAL_FRAME * sizeof(uint32_t));
    if (NULL == avi_mjpeg_size) {
        log_error("avi_mjpeg_size mem err.\r\n");
        goto init_mem_err;
    }

    /* malloc header */
    avi_header_p = pvPortMallocDMA(MJPEG_HEADER_SIZE);
    if (NULL == avi_header_p) {
        log_error("avi_header_p mem err.\r\n");
        goto init_mem_err;
    }

    /* malloc buf */
    if (avi_buf) {
        log_warn("repeat init.\r\n");
        return;
    }
    avi_buf = pvPortMallocDMA(AVI_BUF_MAXSIZE);
    log_warn("avi_buf = %p\r\n", avi_buf);
    if (NULL == avi_buf) {
        log_error("avi_buf mem err.\r\n");
        goto init_mem_err;
    }

    /* set sd header */
    avi_header_buf = pvPortMallocDMA(sizeof(avi_head_t));
    if (NULL == avi_header_buf) {
        log_error("avi_header_buf mem err.\r\n");
        goto init_mem_err;
    }
    avi_head_init(avi_header_buf);
    avi_buf_copy(avi_header_buf, sizeof(avi_head_t));
    return;

  init_mem_err:
    if(avi_mjpeg_size) {
        vPortFree(avi_mjpeg_size);
    }
    if(avi_header_p) {
        vPortFree(avi_header_p);
    }
    if(avi_buf) {
        vPortFree(avi_buf);
    }
    if(avi_header_buf) {
        vPortFree(avi_header_buf);
    }
    return;
}

static uint32_t get_align_2_size(uint32_t len)
{
    return ((len%2) != 0) ? (len+1) : len;
}

#if 0
void bl_memcpy(void *dst, void *src, uint32_t bytes)
{
    __asm volatile(
        "bl_memcpy:                     \n"
        "    push    {r0}               \n"
        "    cmp     r2, #4             \n"
        "    it      lo                 \n"
        "    lslslo  r2, r2, #30        \n"/* Adjust r2 for less_than_4_bytes */
        "    blo     less_than_4_bytes  \n"
        "    ands    r3, r1, #3         \n"
        "    beq     aligned            \n"
        "    negs    r3, r3             \n"/* Next aligned offset = (4 - src & 3) & 3 */
        "    lsls    r3, r3, #31        \n"
        "    ittt    cs                 \n"
        "    ldrhcs  r3, [r1], #2       \n"/* Load if 2 bytes unaligned */
        "    subcs   r2, r2, #2         \n"
        "    strhcs  r3, [r0], #2       \n"/* Save if 2 bytes unaligned */
        "    ittt    mi                 \n"
        "    ldrbmi  r3, [r1] ,#1       \n"/* Load if 1 byte unaligned */
        "    submi   r2, r2, #1         \n"
        "    strbmi  r3, [r0] ,#1       \n"/* Save if 1 byte unaligned */
        "aligned:                       \n"
        "    push    {r4 - r10}         \n"
        "    subs   r2, #32             \n"
        "    blo     less_than_32_bytes \n"
        "L:                             \n"
        "    ldmia  r1!, {r3 - r10}     \n"
        "    subs   r2, #32             \n"
        "    stmia  r0!, {r3 - r10}     \n"
        "    bhs    L                   \n"
        "less_than_32_bytes:            \n"
        "    lsls    r2, r2, #28        \n"
        "    it      cs                 \n"
        "    ldmiacs    r1!, {r3 - r6}  \n"/* Load if 16 bytes remained */
        "    it      mi                 \n"
        "    ldmiami r1!, {r7 - r8}     \n"/* Load if 8 bytes remained */
        "    it      cs                 \n"
        "    stmiacs    r0!, {r3 - r6}  \n"
        "    it      mi                 \n"
        "    stmiami r0!, {r7 - r8}     \n"
        "    lsls    r2, r2, #2         \n"
        "    itt     cs                 \n"
        "    ldrcs   r3, [r1], #4       \n"/* Load if 4 bytes remained */
        "    strcs   r3, [r0], #4       \n"
        "    pop     {r4 - r10}         \n"
        "less_than_4_bytes:             \n"
        "    it      ne                 \n"
        "    ldrne   r3, [r1]           \n"/* Load if ether 2 bytes or 1 byte remained */
        "    lsls    r2, r2, #1         \n"
        "    itt     cs                 \n"
        "    strhcs  r3, [r0],#2        \n"/* Save if 2 bytes remained */
        "    lsrcs   r3, r3, 16         \n"
        "    it      mi                 \n"
        "    strbmi  r3, [r0],#1        \n"/* Save if 1 byte remained */
        "    pop     {r0}               \n"
        "    bx      lr                 \n"
    );
}
#endif

static int sdbuf_get_pack(void)
{
    uint32_t c_frames;
    uint8_t *c_ptr1, *c_ptr2;
    uint32_t c_len1, c_len2;
    uint32_t mjpeg_info_index;
    uint16_t mjpeg_w;
    uint16_t mjpeg_h;

    AVISD_ASSERT(avi_buf);

    /* mem cpy 8byte mjpeg 00db and mjpeg_len */
    mjpeg_info_index = avibuf_tail_index + 4;   /* add '00db' offset, it is image_size */
    avi_buf_copy("00dbinfo", 8);                /* at last change mjpeg info */

    /* fast_copy */
    // log_info("fast_copy_p1 = %p -> %ld\r\n", (avi_buf + avibuf_tail_index), (uint32_t)(avi_buf + avibuf_tail_index)%4);
    // log_info("c_ptr1 = %p -> %ld\r\n", avi_header_p, (uint32_t)(avi_header_p)%4);
    AVISD_ASSERT((uint32_t)(avi_buf + avibuf_tail_index)%4 == 0);
    AVISD_ASSERT((uint32_t)(avi_header_p)%4 == 0);
    // memcpy((uint32_t *)(avi_buf + avibuf_tail_index), (uint32_t *)avi_header_p, (MJPEG_HEADER_SIZE));
    // bl_cpu_word_copy((uint32_t *)avi_header_p, (uint32_t *)(avi_buf + avibuf_tail_index), MJPEG_HEADER_SIZE>>2);
    BL60X_MemCpy4((uint32_t *)(avi_buf + avibuf_tail_index), (uint32_t *)avi_header_p, MJPEG_HEADER_SIZE>>2);
    // bl_memcpy((uint32_t *)(avi_buf + avibuf_tail_index), (uint32_t *)avi_header_p, (MJPEG_HEADER_SIZE));
    // AVISD_ASSERT(memcmp((uint32_t *)(avi_buf + avibuf_tail_index), (uint32_t *)avi_header_p, (MJPEG_HEADER_SIZE)) == 0);

    bl_cam_config_get(NULL, &mjpeg_w, &mjpeg_h);
    *((uint16_t *)(avi_buf + avibuf_tail_index + MJPEG_WIDTH_OFFSET)) = U16HTONL(mjpeg_w);
    *((uint16_t *)(avi_buf + avibuf_tail_index + MJPEG_HEIGHT_OFFSET)) = U16HTONL(mjpeg_h);

    avibuf_tail_index += MJPEG_HEADER_SIZE;

    /* mem cpy payload */
    if (bl_cam_frame_fifo_get(&c_frames, &c_ptr1, &c_len1, &c_ptr2, &c_len2)) {
        // log_warn("get fifo none.\r\n");
        return -3;
    }
  #if DEBUG_MJPEG_SAVED
    {/* test add write sd mjpeg, need fix */
        char file_name[32];
        int file_fd = -1;
        uint8_t *tmp_buf = NULL;
        uint32_t tmp_buf_len = 0;

        memset(file_name, 0, sizeof(file_name));
        sprintf(file_name, TEST_MJPEG_NAME, jpgs_sum);
        file_fd = aos_open(file_name, O_RDWR | O_CREAT | O_TRUNC);
        if (file_fd < 0) {
            AVISD_ASSERT(0);
        }
        tmp_buf = pvPortMallocDMA(300*1024 + 512); //vPortFree
        AVISD_ASSERT(tmp_buf);

        memcpy(tmp_buf, avi_header_p, MJPEG_HEADER_SIZE);
        tmp_buf_len += MJPEG_HEADER_SIZE;

        memcpy(tmp_buf + tmp_buf_len, c_ptr1, c_len1);
        tmp_buf_len += c_len1;

        memcpy(tmp_buf + tmp_buf_len, code_mjpeg_tail_buf, MJPEG_TAIL_SIZE);
        tmp_buf_len += MJPEG_TAIL_SIZE;

        if (get_align_2_size(c_len1) == c_len1) {
            log_info("MJPEG unalign add 1 byte.\r\n");
            memcpy(tmp_buf + tmp_buf_len, &tmp_zero, 1);
            tmp_buf_len += 1;
        }

        aos_write(file_fd, tmp_buf, tmp_buf_len);

        aos_close(file_fd);
        vPortFree(tmp_buf);
    }
  #endif

    {
        static const uint8_t add_tail5_buf[5] = {0xFF, 0xFE, 0x00, 0x01, 0x55};
        static const uint8_t add_tail6_buf[6] = {0xFF, 0xFE, 0x00, 0x02, 0x55, 0x55};
        static const uint8_t add_tail7_buf[7] = {0xFF, 0xFE, 0x00, 0x03, 0x55, 0x55, 0x55};

        // log_info("fast_copy_p2 = %p -> %ld\r\n", (avi_buf + avibuf_tail_index), (uint32_t)(avi_buf + avibuf_tail_index)%4);
        // log_info("c_ptr1 = %p -> %ld\r\n", c_ptr1, (uint32_t)(c_ptr1)%4);
        AVISD_ASSERT((uint32_t)(avi_buf + avibuf_tail_index)%4 == 0);
        AVISD_ASSERT((uint32_t)(c_ptr1)%4 == 0);
        // memcpy((avi_buf + avibuf_tail_index), c_ptr1, (c_len1 - (c_len1 % 4)));
        // bl_cpu_word_copy((uint32_t *)c_ptr1, (uint32_t *)(avi_buf + avibuf_tail_index), c_len1>>2);
        BL60X_MemCpy4((uint32_t *)(avi_buf + avibuf_tail_index), (uint32_t *)c_ptr1, c_len1>>2);
        // bl_memcpy((avi_buf + avibuf_tail_index), c_ptr1, (c_len1 - (c_len1 % 4)));

        // AVISD_ASSERT(memcmp((avi_buf + avibuf_tail_index), c_ptr1, (c_len1 - (c_len1 % 4))) == 0);
        avibuf_tail_index += (c_len1 - (c_len1 % 4));

        if (c_len1 % 4) {
            avi_buf_copy(c_ptr1 + c_len1 - (c_len1 % 4), (c_len1 % 4));
        }

        if (0 == c_len1 % 4) {
            avi_buf_copy((uint8_t *)add_tail6_buf, 6);
            c_len1 += 6;
        } if (1 == c_len1 % 4) {
            avi_buf_copy((uint8_t *)add_tail5_buf, 5);
            c_len1 += 5;
        } if (2 == c_len1 % 4) {
        } else {// 3
            avi_buf_copy((uint8_t *)add_tail7_buf, 7);
            c_len1 += 7;
        }
        avi_buf_copy((void *)code_mjpeg_tail_buf, MJPEG_TAIL_SIZE);
    }

    /* change mjpeg info */
    avi_mjpeg_size[jpgs_sum] = c_len1 + MJPEG_HEADER_SIZE + MJPEG_TAIL_SIZE;
    memcpy((avi_buf + mjpeg_info_index), &avi_mjpeg_size[jpgs_sum], 4);
    jpgs_sum++;

    return 0;
}

static int sdbuf_write(void)
{
    // log_info("sdbuf_write tail = %ld  head = %ld\r\n", avibuf_tail_index, avibuf_head_index);

    avi_wsd_tmp1 = (uint32_t)(*((uint32_t *)0x60b00120));
    if ((avi_buf_size() - (avi_buf_size()%AVI_SD_ALIGN_BLOCK_SIZE)) > 0) {
        aos_write( file_sample_fd, avi_buf_p(), (avi_buf_size() - (avi_buf_size()%AVI_SD_ALIGN_BLOCK_SIZE)) );
        avibuf_head_index += (avi_buf_size() - (avi_buf_size()%AVI_SD_ALIGN_BLOCK_SIZE));
    }
    avi_wsd_tmp2 = (uint32_t)(*((uint32_t *)0x60b00120));
    if (savesd_start_time > 0) {
        avi_wsd_total += (avi_wsd_tmp2 - avi_wsd_tmp1);
    }

    // log_info("tail = %ld  head = %ld\r\n", avibuf_tail_index, avibuf_head_index);

    avi_copy_tmp1 = (uint32_t)(*((uint32_t *)0x60b00120));
    if (avi_buf_size()) {
        memmove(avi_buf, avi_buf_p(), avi_buf_size());

        avibuf_tail_index = avi_buf_size();
        avibuf_head_index = 0;
    } else {
        avibuf_tail_index = 0;
        avibuf_head_index = 0;
    }
    avi_copy_tmp2 = (uint32_t)(*((uint32_t *)0x60b00120));

    if (savesd_start_time > 0) {
        avi_copy_total += (avi_copy_tmp2 - avi_copy_tmp1);
    }
    // log_info("tail = %ld  head = %ld\r\n", avibuf_tail_index, avibuf_head_index);
    return 0;
}

void update_fps(void)
{
    uint32_t tmp;
    uint32_t fps = 0;

    tmp = (int32_t)savesd_end_time - (int32_t)savesd_start_time;

    log_info("total use time   = %ld\r\n", tmp);
    log_info("mem cpy use time = %ld\r\n", avi_copy_total);
    log_info("mem cpy use %ld per \r\n", (avi_copy_total/10/tmp));
    log_info("write sd use time = %ld\r\n", avi_wsd_total);
    log_info("write sd %ld per \r\n", (avi_wsd_total/10/tmp));

    log_info("jpgs_usleep = %ld/%d = %ld ms, fps = %ld\r\n", tmp, MJPEG_TEST_TOTAL_FRAME, tmp/MJPEG_TEST_TOTAL_FRAME, 1000/(tmp/MJPEG_TEST_TOTAL_FRAME));

    fps = (uint32_t)(1000/(tmp/MJPEG_TEST_TOTAL_FRAME));

    if (fps > 25) {
        jpgs_fps = 25;
        jpgs_usleep = 40000;
    } else if (fps < 1) {
        jpgs_fps = 1;
        jpgs_usleep = 1000000;
    } else {
        jpgs_fps = fps;
        jpgs_usleep = 1000000/fps;
    }

    log_warn("need change real jpgs_fps = %ld and jpgs_usleep = %ld\r\n", jpgs_fps, jpgs_usleep);
}

static void sdbuf_write_avitail(void)
{
    AVITailH_t tail_h;
    AVITailData_t tail_data;

    uint32_t i;
    uint32_t offset = 4;

    memcpy(&tail_h.dwList, "idx1", 4);
    tail_h.dwSize = jpgs_sum*16;
    avi_buf_copy(&tail_h, sizeof(AVITailH_t));

    memcpy(&tail_data.dwList, "00db", 4);
    tail_data.dwSize = 0x10;
    for (i = 0; i < jpgs_sum; i++) {
        tail_data.offset = offset;
        tail_data.mjpeglen = get_align_2_size(avi_mjpeg_size[i]);

        offset += get_align_2_size(avi_mjpeg_size[i]) + 8;
        avi_buf_copy(&tail_data, sizeof(AVITailData_t));

        jpgs_totallen += get_align_2_size(avi_mjpeg_size[i]);
    }

    log_info("jpgs_totallen = %ld\r\n", jpgs_totallen);

    aos_write(file_sample_fd, avi_buf_p(), avi_buf_size());
    avibuf_head_index = 0;
    avibuf_tail_index = 0;
}

static void sdbuf_update_avihead(void)
{
    int fd = -1;
    uint8_t *buf = avi_buf;
    avi_head_t *head = (avi_head_t *)avi_buf;
    uint16_t mjpeg_w = 0;
    uint16_t mjpeg_h = 0;

    fd = aos_open((const char *)avi_file_name, O_RDWR);
    if (fd < 0) {
        log_error("open fd error.\r\n");
        return;
    }

    aos_read(fd, buf, AVI_SD_ALIGN_BLOCK_SIZE);

    bl_cam_config_get(NULL, &mjpeg_w, &mjpeg_h);
    jpgs_width = mjpeg_w;
    jpgs_high = mjpeg_h;
    log_info("jpgs_totallen = %ld, jpgs_sum = %ld, jpgs_width = %ld, jpgs_high = %ld, jpgs_fps = %ld, jpgs_usleep = %ld\r\n",
        jpgs_totallen, jpgs_sum, jpgs_width, jpgs_high, jpgs_fps, jpgs_usleep);
    avi_head_update(head, jpgs_totallen, jpgs_sum, jpgs_width, jpgs_high, jpgs_fps, jpgs_usleep);

    aos_close(fd);
    fd = -1;

    fd = aos_open((const char *)avi_file_name, O_RDWR);
    if (fd < 0) {
        log_error("open fd error.\r\n");
        return;
    }
    aos_write(fd, buf, AVI_SD_ALIGN_BLOCK_SIZE);
    aos_close(fd);
}

static void update_avi_header_p(void)
{
    uint16_t mjpeg_w = 0;
    uint16_t mjpeg_h = 0;

    if (NULL == avi_header_p) {
        return;
    }
    switch (MJPEG_quality_current) {
        case 5:
        {
            memcpy(avi_header_p, (uint8_t *)code_mjpeg_header_Q5, MJPEG_HEADER_SIZE);
        }
        break;
        case 10:
        {
            memcpy(avi_header_p, (uint8_t *)code_mjpeg_header_Q10, MJPEG_HEADER_SIZE);
        }
        break;
        case 25:
        {
            memcpy(avi_header_p, (uint8_t *)code_mjpeg_header_Q25, MJPEG_HEADER_SIZE);
        }
        break;
        case 50:
        {
            memcpy(avi_header_p, (uint8_t *)code_mjpeg_header_Q50, MJPEG_HEADER_SIZE);
        }
        break;
        case 75:
        {
            memcpy(avi_header_p, (uint8_t *)code_mjpeg_header_Q75, MJPEG_HEADER_SIZE);
        }
        break;
        case 100:
        {
            memcpy(avi_header_p, (uint8_t *)code_mjpeg_header_Q100, MJPEG_HEADER_SIZE);
        }
        break;
        default:
        {
            log_error("qulity error.\r\n");
        }
        break;
    }
    
    bl_cam_config_get(NULL, &mjpeg_w, &mjpeg_h);
    *((uint16_t *)(avi_header_p + MJPEG_WIDTH_OFFSET)) = U16HTONL(mjpeg_w);
    *((uint16_t *)(avi_header_p + MJPEG_HEIGHT_OFFSET)) = U16HTONL(mjpeg_h);
}

static void mjpegsd_config(char *buf, int len, int argc, char **argv)
{
    if (argc > 3) {
        log_error("arg err.\r\n");
        return;
    }

    if (2 <= argc) {
        MJPEG_quality_current = atoi(argv[1]);
    }

    if (3 <= argc) {
        snprintf(avi_file_name, sizeof(avi_file_name), "/sdcard/%s", argv[2]);
        avi_file_name[AVI_FILE_NAME_MAXLEN - 1] = '\0';
    }

    log_info("config quality = %d\r\n", MJPEG_quality_current);

    bl_cam_config_update(MJPEG_quality_current);
    bl_cam_restart(1);

    update_avi_header_p();
}

static void mjpegsd_task_entry(void *arg)
{
    uint32_t tmp;

    aos_msleep(1000);

    mjpegsd_init();

    mjpegsd_config(NULL, 0, 0, NULL);

    aos_msleep(1000);

    while (1) {
        if (jpgs_sum == 0) {
            savesd_start_time = aos_now_ms();
        }

        if (jpgs_sum < MJPEG_TEST_TOTAL_FRAME) {
            if (0 == sdbuf_get_pack()) {
                bl_cam_frame_pop();
                // log_info("write %ld.jpeg start\r\n", jpgs_sum);
                tmp = aos_now_ms();
                if (0 == sdbuf_write()) {
                    tmp = aos_now_ms() - tmp;
                    // log_info("write %ld.jpeg use %ld ms\r\n", jpgs_sum, tmp);
                }
            }
        } else {
            savesd_end_time = aos_now_ms();
            update_fps();
            log_warn("jpgs_sum = %ld, so break.\r\n", jpgs_sum);
            sdbuf_write_avitail();
            aos_close(file_sample_fd);
            sdbuf_update_avihead();
            break;
        }
        aos_msleep(5);
    }
}

#define CAM_GPIO_PWR (15)
static void enable_camera_module(void)
{
    /*Disable Power Down Mode*/
    bl_gpio_output_set(CAM_GPIO_PWR, 0);
    bl_gpio_enable_output(CAM_GPIO_PWR, 0, 0);
}

static void camera_task_entry(void *pvParameters)
{
    uint16_t frame_count = 0;
    uint32_t tick_now, tick_last = 0;
    rt_camera_desc *desc;

    /*enable_24mhz*/
    bl_cam_enable_24MRef();
    aos_msleep(1000);
    enable_camera_module();
    aos_msleep(1000);

    SCCB_Init();
    desc = (rt_camera_desc *)(camera_module_init());
    if (NULL == desc) {
        return;
    }
    /*enable CAM module*/
    bl_cam_init(1, desc);

    //cpu_utils_usage_init();
    tick_last = aos_now_ms();

    aos_task_new("mjpeg_tsk", mjpegsd_task_entry, NULL, 2048);
    while (1) {
        tick_now = aos_now_ms();
        if (((int32_t)tick_now) - ((int32_t)tick_last) > 5*1000) {
            tick_last = aos_now_ms();
            /*debug every 30*/
            printf("[MAIN] FPS is %u\r\n", (*(volatile uint16_t*)0x40016028 - frame_count)/5);
            frame_count = *(volatile uint16_t*)0x40016028;
        }
        aos_msleep(1);
    }
}

static void cmd_avisd_start(char *buf, int len, int argc, char **argv)
{
    aos_task_new("camera_tsk", camera_task_entry, NULL, 2048);
}

static void cmd_avisd_config(char *buf, int len, int argc, char **argv)
{
    mjpegsd_config(buf, len, argc, argv);
}
// STATIC_CLI_CMD_ATTRIBUTE makes this(these) command(s) static
const static struct cli_command cmds_user[] STATIC_CLI_CMD_ATTRIBUTE = {
    { "avisd_start", "start avi tasks", cmd_avisd_start },
    { "avisd_config", "avisd_config 100", cmd_avisd_config },
};

int helper_avisd_cli_init(void)
{
    // static command(s) do NOT need to call aos_cli_register_command(s) to register.
    // However, calling aos_cli_register_command(s) here is OK but is of no effect as cmds_user are included in cmds list.
    // XXX NOTE: Calling this *empty* function is necessary to make cmds_user in this file to be kept in the final link.
    //return aos_cli_register_commands(cmds_user, sizeof(cmds_user) / sizeof(cmds_user[0]));
    return 0;
}
